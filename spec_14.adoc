ifdef::env-github[:outfilesuffix: .adoc]

14/Canonical Job Specification
==============================

A domain specific language based on YAML is defined to express the
resource requirements and other attributes of one or more programs
submitted to a Flux instance for execution.  This RFC describes the
canonical jobspec form, which represents a request to run exactly
one program.


* Name: github.com/flux-framework/rfc/spec_14.adoc
* Editor: Tom Scogland <scogland1@llnl.gov>
* State: raw

== Language

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to
be interpreted as described in http://tools.ietf.org/html/rfc2119[RFC 2119].

== Related Standards

* link:spec_4{outfilesuffix}[4/Flux Resource Model]
* link:spec_12{outfilesuffix}[12/Flux Task and Program Execution Services]

== Goals

* Express the resource requirements of a program to the scheduler.
* Allow graph-oriented resource requirements to be expressed.
* Express program attributes such as arguments, run time, and
task layout, to be considered by the program execution service (RFC 12)
* Express dependencies relative to other programs executing within
the same Flux instance.
* Emphasize expressivity over simplicity, as this canonical form
may be generated from other user-friendly forms or interfaces.
* Facilitate reproducible runs.
* Promote sharing and reuse of jobspec.

== Overview

This RFC describes the canonical form of "jobspec", a domain specific
language based on YAML[1].  The canonical jobspec SHALL consist of
a single YAML document representing a reusable request to run
exactly one program.  Hereafter, "jobspec" refers to the canonical
form, and "non-canonical jobspec" refers to the non-canonical form.

Non-canonical jobspec SHALL be decomposed into jobspec before
it is enqueued for the scheduler and program execution service.

User facing tools MAY generate jobspec from non-canonical jobspec,
or other sources.  Such tools MAY:

* generate a batch of dependent jobspecs representing a scientific workflow
* generate a stream of jobspecs representing a steered parameter study
* convert simulation parameters into jobspec containing computed
resource requirements, etc.
* convert command line arguments to jobspec, e.g. "flux mpirun"

=== Jobspec and Program Life Cycle

The jobspec SHALL be submitted to a job submission service.  Malformed
jobspec SHALL be immediately rejected by the job submission service.
A stack of plugins SHALL test jobspec against site or user defined
criteria, and on failure, MAY reject the jobspec, or MAY warn the user
and continue on.  The job submission service SHALL enqueue the jobspec
for consideration by the scheduler.

The scheduler SHALL consider each enqueued jobspec in the context of its
dependencies and the pool of available resources.  When the scheduler
chooses to execute a job, it allocates resources, associates them
with the jobspec, and notifies the program execution service to start
the program(s).

The program execution service, described in RFC 12, launches the program(s).
Task slots, containment, and task layout SHALL be created within the
allocated resources as described by the jobspec, or if that is not
possible, the job SHALL enter a failed state and resources SHALL
be returned to the scheduler.

Once a job is retired, the jobspec SHALL be retained as part of
its provenance record.

=== Resource Matching

Resources are represented as hierarchies or graphs, as described in RFC 4.

FIXME: describe how Flux hierarchical resource representation affects
jobspec design.

=== Terminology

FIXME: Fill in

== Jobspec Language Definition

FIXME: Fill in

== Basic Use Cases

To implement basic resource manager functionality, the following use
cases SHALL be supported by the jobspec:

=== Section 1: Resource only requests

'''
Use Case 1.1:: Request Single Resource with Count
+
Specific Example:: Request 4 nodes
+
Existing Equivalent:: `salloc -N4` or `qsub -l nodes=4`
+
[source,yaml]
resources:
    - type: node
      count: 4

'''
Use Case 1.2:: Request a range of a type of resource
+
Specific Example:: Request between 3 and 30 nodes
+
Existing Equivalent:: `salloc -N3-30`
+
[source,yaml]
resources:
    - type: node
      count: "[3:30]"

'''
Use Case 1.3:: Request M nodes with a minimum number of sockets per node
and cores per socket
+
Specific Example:: Request 4 nodes with at least 2 sockets each,
and 4 cores per socket
+
Existing Equivalent::
`srun -N4 --sockets-per-node=2 --cores-per-socket=4` or
`srun -N4 -B '2:4:*'` or
`oarsub -l nodes=4/sockets=2/cores=4`
+
[source,yaml]
resources:
    - type: node
      count: 4
      with:
        - type: socket
          count: 2
          with:
            - type: core
              count: 4

'''
Use Case 1.4:: Complex example from OAR
+
Specific Example::
[quote, http://oar.imag.fr/docs/2.5/user/usecases.html#mixing-every-together]
ask for 1 core on 2 nodes on the same cluster with 4096 GB of memory
and Infiniband 10G + 1 cpu on 2 nodes on the same switch with bicore
processors for a walltime of 4 hours

Existing Equivalent::
+
 oarsub -I -l "{memnode=4096 and ib10g='YES'}/cluster=1/nodes=2/core=1+{nbcore=2}/switch=1/nodes=2/cpu=1,walltime=4:0:0"
+
[source,yaml]
resources:
    - type: cluster
      count: 1
      with:
        - type: node
          count: 2
          with:
            - type: memory
              amount: 4GB
            - type: ib10g
        - type: switch
          with:
            type: node
            count: 2
            with:
                - type: core
walltime: 4h

'''
Use Case 1.5:: Request resources across multiple clusters
+
Specific Example::
Ask for 1 core on 15 nodes across 2 clusters (total = 30 cores)
+
Existing Equivalent:: `oarsub -I -l /cluster=2/nodes=15/core=1`
+
[source,yaml]
resources:
    - type: cluster
      count: 2
      with:
          - type: Node
            count: 15
            with:
              - type: core

'''
Use Case 1.6:: Request N cores across M switches
+
Specific Example::
Request 3 cores across 3 switches
+
Existing Equivalent:: `oarsub -I -l /switch=3/core=1`
+
[source,yaml]
resources:
    - type: switch
      count: 3
      with:
        - type: core


=== Section 2: Resource and task jobspec

'''
Use Case 2.1:: Run N tasks across M nodes
+
Specific Example:: Run `hostname` 20 times on 4 nodes, 5 per node
+
Existing Equivalent::
`srun -N4 -n20 hostname` or `srun -N4 --ntasks-per-node=5 hostname`
or 
+
`qsub -l nodes=4,mppnppn=5`
+
[source,yaml]
resources:
    - type: node
      count: 4
      with:
        - type: task
          command: hostname
          count: 5

'''
Use Case 2.2:: Run N tasks across M nodes, unequal distribution
+
Specific Example:: Run 5 copies of `hostname` across 4 nodes,
default distribution
+
Existing Equivalent:: `srun -n5 -N4 hostname`
+
[source,yaml]
tasks:
    - command: hostname
      count: 5
with:
    - type: node
      count: 4

'''
Use Case 2.3:: Run N tasks, Require M cores per task
+
Specific Example:: Run 10 copies of `myapp`, require 2 cores per copy,
for a total of 20 cores
+
Existing Equivalent:: `srun -n10 -c 2 myapp`
+
[source,yaml]
tasks:
    - command: myapp
      count: 10
      with:
          - type: core
            count: 2


'''
Use Case 2.4:: Run different binaries with differing resource
requirements as single program
+
Specific Example:: 11 tasks, one node, first 10 using one core and 4G of RAM for
`read-db`, last using 6 cores and 24G of RAM for `db`
+
Existing Equivalent:: None Known
+
[source,yaml]
resources:
  - type: node
    with:
      - type: task # Note, special resource type "task" to add a level
        count: 10
        command: read-db
        with:
          - type: core
          - type: memory
            amount: 4GB
      - type: task
        command: db
        with:
          - type: core
            count: 6
          - type: memory
            amount: 24GB

'''
Use Case 2.5:: Run command requesting minimum amount of RAM per core
+
Specific Example::
Run 10 copies of `app` across 10 cores with at least 2GB per core
+
Existing Equivalent:: `srun -n 10 --mem-per-cpu=2048 app`
+
[source,yaml]
----
tasks:
  - command: app
resources:
  - type: group
    count: 10
    with:
    - type: Memory
      amount: 2GB
    - type: core
----
or
+
[source,yaml]
resources:
  - type: task
    count: 10
    command: app
    with:
      - type: Memory
        amount: 2GB
      - type: core

'''
Use Case 2.6:: Run N copies of a command with minimum amount of RAM per node
+
Specific Example::
Run 10 copies of `app` across 2 nodes with at least 4GB per node
+
Existing Equivalent:: `srun -n10 -N2 --mem=4096 app` or
+
`oarsub -p memnode=4096 -l nodes=2 "taktuk -c oarsh -f $OAR_FILE_NODES broadcast exec [app]"`
+
[source,yaml]
tasks:
    - command: app
      count: 10
resources:
    - type: node
      count: 2
      with:
        - type: memory
          amount: 4G

== References

* [1]http://yaml.org/spec/current.html#representation[YAML Ain't Markup Language (YAMLâ„¢) Version 1.1], O. Ben-Kiki, C. Evans, B. Ingerson, 2004.
