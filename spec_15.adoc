ifdef::env-github[:outfilesuffix: .adoc]

15/Independent Minister of Privilege for Flux: The Security IMP
===============================================================

This specification describes Flux Security IMP, a privileged service
used by multi-user Flux instances to launch, monitor, and control
processes running as users other than the instance owner.

* Name: github.com/flux-framework/rfc/spec_10.adoc
* Editor: Mark A. Grondona <mgrondona@llnl.gov>
* State: raw

== Language

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to
be interpreted as described in http://tools.ietf.org/html/rfc2119[RFC 2119].

== Related Standards

*  link:spec_12{outfilesuffix}[12/Flux Security Architecture]

== Introduction

In the traditional resource management model, a monolithic resource
manager runs with the credentials of a privileged user, typically using
long-running daemons with elevated privileges on compute resources. These
daemons allow the resource manager to complete necessary privileged
work, such as modification of containers, system preparation (such as
prolog/epilog scripts), and most importantly allow the transition of
credentials to that of the requesting user, so that jobs may be successfully
executed in a multi-user environment.

Drawbacks to this monolithic approach include:

 * Total amount of code running with privilege is increased above what
   is strictly necessary
 * Testing of privileged code is more difficult
 * Security patches and updates require a new release of entire project

In the Flux model, however, an instance runs at most with the credentials
of the *instance owner*, including all processes running on computational
resources of the instance. This design works well for single-user instances
of Flux, but multi-user capable instances require some mechanism to perform
privileged operations, most notably when executing work on behalf of a
non instance owner (a guest).

In the Flux system, this privilege - along with all related operations - is
contained within a single service, the _Independent Minister of Privilege_
(IMP), which is responsible for allowing instance owners to run work on
behalf of a guest when the guest user has authorized the instance to do so.

By placing all code running with elevated privilege into a single service,
the following benefits are realized:

 * Code running under privilege is reduced to the logical minimum
 * The privileged service can be tested separately from other Flux components
 * The privileged software release cycle is decoupled from core
   Flux code, allowing updates to be applied out of band.
 * The privileged service is completely under sysadmin control, while
   still allowing users to run test or private versions of Flux even
   in multi-user mode.
 * More fine grained administrative control of privilege. For example,
   simple filesystem access controls may be used to limit which
   users are allowed to run multi-user without preventing these users
   from launching Flux instances altogether.
 * Arbitrary users can run multi-user instances of Flux, thus allowing
   users to share their jobs 

=== User Roles

For the purposes of this RFC there are three main user roles:

 owner, or resource owner
  The user under which a Flux instance is running, not privileged.
  This user is considered the owner of all resources to which the Flux
  instance is running.

 guest
  A user wishing to use services or run work in a Flux instance when
  they are not the instance owner.

 superuser
  A user with access to perform required privileged operations during
  multi-user execution, such as gaining credentials of other users,
  system setup or initialization, container manipulation, etc. Typically
  the root user.

=== Implementation Requirements

The Flux Security IMP SHALL be implemented with the following overall
design

 * The IMP SHALL be an independent Flux Framework project, with the ability
   to be tested standalone
 * The IMP SHALL be implemented as an executable, `flux-security-imp`,
   which MAY be installed with setuid permissions in cases where multi-user
   Flux is required.
 * The IMP executable SHALL use privilege separation to allow processing
   of user provided data such as command line options and stdin in an
   unprivileged process.
 * The IMP SHALL accept and process data using stdin, to avoid putting
   sensitive data on the command line or environment.

Implementation of the IMP as a separately installed, setuid executable
allows sysadmin control over where and how the IMP is enabled. If the
`flux-security-imp` executable is not installed, or installed without
setuid bits enabled, then multi-user Flux is simply not available, though
single user instances of Flux will still operate. The file permissions,
access controls, or SELinux policy of `flux-security-imp` may also be
manipulated to restrict access to a user or group of users. For instance,
a site may configure permissions such that only a `flux` user has execute
permissions, thus allowing a multi-user system instance running as `flux`,
but disallowing sub-instance jobs access to multi-user capabilities.

=== Overall Design

The operation of the Flux Security IMP is based on the use of signed
request credentials by both the resource owner and a guest user that
wants to make use of those resources.

When a guest makes a request for a job to a multi-user instance of
Flux, the guest will create a request with information such as the job
specification, a time-to-live, and authorized resource owner, and signs
that request, thereby authorizing a specific owner to execute that request
on behalf of the guest.

The signed request then becomes part of the user's job. It cannot be
tampered with or accidentally altered because of the guest user's
signature.  When the job is scheduled by the instance, the owner
assigns a resource set to the job, and signs that data _including_ the
user's original request. The resource owner's signature and the assigned
resources, in addition to an additional time-to-live, become a job request
credential that authorizes the guest user access to the specific resources
in the resource set.

This final signed job request becomes the input to the
`flux-security-imp` process. This allows the IMP to verify that the
resource owner has granted certain resources to a guest user, and that
the guest has authorized the resource owner to execute specific work on
their behalf.

To verify signatures in the request, the IMP needs access to
the public keys of both owner and guest. The mechanism by which these
keys are obtained is outside of the scope of this RFC. However it is
assumed that the mechanism will be implemented as a plugin, and that
public certificates may be distributed through site-specific means,
though it may be feasible to store and distribute public keys through
Flux instances themselves using certificates signed by a trusted CA.

Once the verification step is complete, the privileged IMP will then
change credentials to the guest user and exec the configured user work,
with optional hooks for privileged setup, containment and so on.

== Job Request Credential

The proposed contents of the Job Request Credential is as follows

 * User Request (`U`) (described below)
 * Assigned resource set
 * Timestamp and TTL
 * Owner Signature (of above fields)

Where user request `U` is the signed original user request or reference
to such a request, which SHALL contain

 * Jobspec as per link:spec_14{outfilesuffix}[14/Canonical Job Specification]
 * UUID
 * Timestamp and TTL
 * Intended recipient (instance owner)
 * Allowed resource set
 * User signature (of above fields)

Where above fields have the following specific meanings and requirements

 * _Assigned resource set_ is the list of resources assigned to this
   job by the resource owner
 * _Timestamp and TTL_ signifies that the request in question SHALL
   only be valid between _Timestamp_ and _Timestamp+TTL_. This puts a
   time horizon on request usage
 * _UUID_ is a globally unique identifier
 * _Intended recipient_ is set to the instance owner that is the target
   of the request. This ensures that the user's request cannot be
   used by another arbitrary user.
 * The _user signature_ signs all fields of the user request
 * The _owner signature_ signs all fields of the Job Request Credential
   _including_ the user request and the user's signature


== IMP Internal Operation

=== Privilege Separation

When the `flux-security-imp` is invoked _and_ has setuid permissions, it
SHALL first perform privilege separation. An underprivileged child is
invoked _as the instance owner_, and this temporary child handles
processing any input, including but not limited to

 * arguments
 * environment
 * processing of marshaled job request on stdin
 * connecting to instance to obtain any missing data or data
   referenced by content hash

The underprivileged child then SHALL sanitize and canonicalize the
job request and "share back" the canonicalized signed job request in a
safe export of data to the privileged IMP parent.

=== Request Verification

Once the privileged IMP process has obtained the canonicalized Job
Request, it SHALL perform the following verification steps:

 1. Verify owner signature
 2. Verify owner has access to assigned resource set
 3. Verify guest signature on user request `U`
 4. Verify TTL on Job and User requests
 5. Verify recipient matches resource owner
 6. Verify, if included, that assigned resource set is a strict subset
    of the allowed resource set

=== IMP post-verification execution

After request verification is complete, the `flux-security-imp`
invokes required job setup code as the superuser. This setup code SHALL
be implemented as system-installed and verified plugins, and MAY include
such things as

 * Execution of some sort of job prolog
 * modification of system settings
 * creation of directories
 * state cleanup

Once privileged setup is complete, the security IMP SHALL generate a log
message or other audit trail for the individual request.  Then IMP then
SHALL proceed to obtain credentials of the guest user and finally exec(2)
the work as encoded in the signed user request. After the call to exec(2)
the security IMP is replaced by the guest user processes.

=== Other IMP operational requirements

A multi-user instance of Flux not only requires the ability to execute
work as a guest user, but it must also have privilege to monitor and
kill these processes as part of normal resource manager operation.
The following requirements are considered necessary and sufficient for
this functionality.

 * The IMP MUST include some mechanism for process tracking.
 * The IMP SHALL implement a method to determine which guest user
   processes are allowed to be signaled or terminated by the owner.
 * The process tracking implementation SHALL be defined by a plugin,
   such that it is possible for the IMP to implement different process
   tracking mechanisms on different systems.
 * The owner's operational abilities on guest user processes SHALL
   be limited to those strictly necessary for process signaling, status,
   and control.
 * In the case process tracking functionality is not available, the Flux
   Security IMP should refuse to function.

==== Signaling and terminating jobs in a multi-user instance

For terminating and signaling processes the IMP SHALL include a `kill`
subcommand which, using the process tracking functionality, SHALL allow
an instance owner to signal or terminate any guest processes including
ancestors thereof that were started by the owner's instance.

==== Flux job prolog and epilog

A multi-user instance of Flux may also require the ability to run job
*prolog* and *epilog* for jobs. These scripts are typically site-supplied
administrative scripts which are expected to run as a privileged user,
and therefore will require the IMP to execute. In support of prolog
and epilog scripts, the IMP has the following requirements:

 * The IMP SHALL implement `prolog` and `epilog` subcommands which allow
   a multi-user instance owner to run a system configured script.
 * When run in `prolog` or `epilog` mode, the IMP MUST return the
   exit status of the script to the caller.
 * The IMP MAY contain a method to limit execution of job prolog
   and epilog scripts to a user or set of users. This can be used
   to limit prolog/epilog script execution to system instances only.

=== Credential Format

TBD

=== IMP Plugin Interface

TBD


=== IMP configuration

On execution, the `flux-security-imp` SHALL read a site configuration
file which MAY contain site-specific information such as paths to trusted
executables, plugin locations, certificate authority information etc.
The IMP SHALL check for correct permissions on all configuration
files to reduce the risk of tampering.

=== Specific Defenses

This section describes some attacks and their specific defenses. It
is still a work in progress.

 * _Executing arbitrary process as another user_: The entirety of a user
   job request, including executables, arguments, working directory,
   environment variables, etc, is signed by the user. Without access
   to user's private key  a request cannot be forged, even by the
   instance owner.

 * _Spoofing a user key_, where `flux-security-imp` is fooled into using
   an invalid or manufactured public key for a guest user, thereby allowing a
   different user or instance owner to run arbitrary code as another user.
   A method for administrative verification of public keys will be used,
   e.g. public certificates signed by a trusted authority, or an out-of-band,
   trusted key infrastructure will be utilized. The source of the verification
   SHALL be part of configuration under control of system admins *only*.

 * _Replay attacks_, where a user's job request is run again without their
   express permission, or a request is taken to another system and executed
   without authority. The _intended recipient_ field of the user request
   protects against users other than the instance owner using the
   guest request, and a fixed time-to-live prevents the request from
   being used indefinitely. Finally, the `flux-security-imp` logs all
   invocations, thereby allowing replays to be detected and audited.

[sect2]
== References

